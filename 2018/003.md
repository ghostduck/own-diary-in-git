# Mongo

# Shell ... and Linux?
## softlink, hardlink and inode (Linux Filesystem and `ln` related)
softlink - just like shortcut in Windows, only pointing to a directory/file path. Its length is string length of the path.

Its permission doesn't matter.

hardlink ... may not be 100% correct here, but the concept is not wrong in this explanation.

Each file is actually a binary blob,  Linux uses an inode to point to it and each inode has an id. (The number you see in `ls`)

hardlink creates another link point to the same inode, and increases its counter.

So if we create a hardlink, we cannot really say which is the "original" file.

Disk consumption should not change (for that inode/binary blob) when we create hard link -- not counting that hard link itself

That hardlink file have the same attributes/permissions as the "original" file, since they have the same inode. (check `stat filepath`)

## Invoking Shells (and polluting variables)
Pay attention to how you run shell

```
# start a new shell, when you exit it go back to previous one
$ ksh 

# terminate current one, start AND REPLACE with this new one
$ exec ksh 
```

## Invoking Scripts
Quite similar to invoking shells

```
# start a new shell, go back to previous one when exit
$ sh ./billy.sh 

# end current one, start and replace with new one
$ exec ./billy.sh 
```

Something new?? `source`

```
$ . ./billy.sh

# same as above, I prefer using this when learning
$ source ./billy.sh 
```

`source` make current shell to read and execute that file, and apply its change to current shell -- useful to update current environment

Also return exit status of last command in that file.

In this example, `billy.sh` needs to be readable.

## Wildcard Metacharacters (`*?[](list)` and `^-` in `[]` )

I mix them up with regex

```
# Its example of meta character but not regex

$ rm d*y # removes diary file

# regex for all strings matching d*y would be d.*y actually ... be careful monkaS
```

NOTES from handbook: `The wildcard expands *before* the command runs.`

## Metacharacters in double quote and single quote
Double or single quote in other languages like JS,C/C++,Python doesn't make a difference, but not in Shell?

```
# billy.sh inside my home directory

$ echo $HOME b* # NO QUOTES AT ALL
# /home/billy billy.sh

$ echo '$HOME b*' # single quote, remove all special meanings
# $HOME b*

$ echo "$HOME b*" # double quote, every metacharacters other than '$,`,\ loses its meaning'
# /home/billy b*
# * loses its meaning in this case
```

## IO redirection/appending, setting new file descriptor
Some used it before, but not in deep details

Simple examples:
```
# input text files' context to program as if we type from keyboard
$ ./billy < input.txt 

# output (standard output) to file instead of printing to screen
$ ./billy > output.txt

# can be done in one line
# Note that not chaining here!! NO CHAINING HERE!!
$ ./billy.sh < input.txt > output.txt

# same as above, order ... doesn't matter?
$ ./billy.sh>output.txt<input.txt

# spacing seems doesn't matter too?

# Append output with >>, single > will destory original content
$ ./billy.sh >> output.txt
``` 

### Advanced -- file descriptor

0 is input (usually omitted)

1 is standard output (screen)

2 is standard error (screen)

3-9 are custom, we can setup like ...

`./billy.sh 3> another/file` 

#### The moment you want to say "Order LUL"

From http://wiki.bash-hackers.org/syntax/redirection

```
# { echo OUTPUT; echo ERRORS >&2; } is to simulate something that outputs to STDOUT and STDERR

# WRONG -- ERRORS on screen, OUTPUT null
$ { echo OUTPUT; echo ERRORS >&2; } 2>&1 1>/dev/null

# CORRECT
$ { echo OUTPUT; echo ERRORS >&2; } 1>/dev/null 2>&1
```

Explanation: There is no auto-chaining.

`2>&1` redirects stderr to stdout ... At this current moment stdout is still screen. 

`1>/dev/null` stdout goes to null.

So errors is printed on screen.

The correct order: `1>/dev/null` set stdout to null, then `2>&1` stderr also goes to 1 (null now)

Or you can think it like this:
```
var 1 = 'screen'
var 2 = 'screen'

# 2>&1
2 = 1

# 1>/dev/null
1 = '/dev/null'

# So 2 is still 'screen'. 

# Reverse the order then you will get the output you want

```

## () and {}
{} runs in current shell, while () runs in a new one

Don't forget spaces -- `{ls billy*;ls billy*;}` will fail but `{ ls billy*;ls billy*;}` is ok

## sed
Quite easy to forget -- each substitution you run only works once (first occurance) each line, so you will need to supply the global flag (-g) if you want

Also, don't try to make your input file the output destination.


Substitution

`sed s/pattern/subpatternwiththis/flags`

s means substitution

/ is the delimiter you choose, can be anything actually. But be careful if you choose a metacharacter without a proper quoting ...

pattern ... very likely to be a regex

subpatternwiththis -- replace the thing that matches pattern

For regex using reference group like: `([a-z]*)\1` may fail like this. 

```
$ echo abcd123 | sed 's/([a-z]*).*/\1/'
sed: -e expression #1, char 16: invalid reference \1 on `s' command's RHS
```

That regex is valid ... for extended regex. So you can fix the problem by using it with flag `-r`.

```
$ echo abcd123 | sed -r 's/([a-z]*).*/\1/'
abcd
```

That can save you a lot of backslashes `(\)`

`sed 'regexforselection s/...'`

We can add regex to select lines.


