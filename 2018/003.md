# Mongo

# Shell ... and Linux?
## softlink, hardlink and inode (Linux Filesystem and `ln` related)
softlink - just like shortcut in Windows, only pointing to a directory/file path. Its length is string length of the path.

Its permission doesn't matter.

hardlink ... may not be 100% correct here, but the concept is not wrong in this explanation.

Each file is actually a binary blob,  Linux uses an inode to point to it and each inode has an id. (The number you see in `ls`)

hardlink creates another link point to the same inode, and increases its counter.

So if we create a hardlink, we cannot really say which is the "original" file.

Disk consumption should not change (for that inode/binary blob) when we create hard link -- not counting that hard link itself

That hardlink file have the same attributes/permissions as the "original" file, since they have the same inode. (check `stat filepath`)

## Invoking Shells (and polluting variables)
Pay attention to how you run shell

```
# start a new shell, when you exit it go back to previous one
$ ksh 

# terminate current one, start AND REPLACE with this new one
$ exec ksh 
```

## Invoking Scripts
Quite similar to invoking shells

```
# start a new shell, go back to previous one when exit
$ sh ./billy.sh 

# end current one, start and replace with new one
$ exec ./billy.sh 
```

Something new?? `source`

```
$ . ./billy.sh

# same as above, I prefer using this when learning
$ source ./billy.sh 
```

`source` make current shell to read and execute that file, and apply its change to current shell -- useful to update current environment

Also return exit status of last command in that file.

In this example, `billy.sh` needs to be readable.

## Wildcard Metacharacters (`*?[](list)` and `^-` in `[]` )

I mix them up with regex

```
# Its example of meta character but not regex

$ rm d*y # removes diary file

# regex for all strings matching d*y would be d.*y actually ... be careful monkaS
```

NOTES from handbook: `The wildcard expands *before* the command runs.`

## Metacharacters in double quote and single quote
Double or single quote in other languages like JS,C/C++,Python doesn't make a difference, but not in Shell?

```
# billy.sh inside my home directory

$ echo $HOME b* # NO QUOTES AT ALL
# /home/billy billy.sh

$ echo '$HOME b*' # single quote, remove all special meanings
# $HOME b*

$ echo "$HOME b*" # double quote, every metacharacters other than '$,`,\ loses its meaning'
# /home/billy b*
# * loses its meaning in this case
```

## IO redirection/appending, setting new file descriptor


## () and {}
{} runs in current shell, while () runs in a new one

Don't forget spaces -- `{ls billy*;ls billy*;}` will fail but `{ ls billy*;ls billy*;}` is ok
